<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Blither Boom"><meta name="copyright" content="Blither Boom"><meta name="generator" content="Hexo 6.2.0"><meta name="theme" content="hexo-theme-yun"><title>笔记-数据与算法 | Guo_Yun</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/star-markdown-css@0.4.1/dist/yun/yun-markdown.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prism-theme-vars/base.css"><script src="https://fastly.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".markdown-body img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/katex.min.js"></script><link rel="stylesheet" type="text/css" href="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.css"><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><script defer src="https://fastly.jsdelivr.net/npm/katex@latest/dist/contrib/auto-render.min.js"></script><script type="module">import { renderKatex } from '/js/utils.js'
document.addEventListener("DOMContentLoaded", () => {
  renderKatex({
    ...{},
    ...true?.options,
  });
});</script><link rel="icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="preconnect" href="https://fastly.jsdelivr.net/npm/" crossorigin><script id="yun-config">
    window.Yun = {}
    window.CONFIG = {"hostname":"blitherboom812.github.io","root":"/","title":["摸","🐟","人","的","日","常"],"version":"1.10.11","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.yunyoujun.cn/img/avatar/none.jpg","fireworks":{"colors":null},"vendors":{"host":"https://fastly.jsdelivr.net/npm/","darken":"https://fastly.jsdelivr.net/npm/darken@1.5.0"}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/hexo-theme-yun.js" type="module"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap"><meta name="description" content="相关资源Princeton Algorithm 4th Edition 课程说明课程内容数据处理，数学模型，算法分析 非数值问题： 数据结构：线性表，栈，队列，串，树，图 非数值算法：查找，排序 数值问题： 误差分析 线性方程组 非线性方程 拟合与插值 最优化初步 算法设计：蛮力，分治、减治、贪心、动态规划、搜索算法 绪论数据与算法数学模型对于现实世界的某一特定对象，为特定目的而得到的一个抽象的简">
<meta property="og:type" content="article">
<meta property="og:title" content="笔记-数据与算法">
<meta property="og:url" content="https://blitherboom812.github.io/2022/09/13/DataAndAlgorithms/index.html">
<meta property="og:site_name" content="Guo_Yun">
<meta property="og:description" content="相关资源Princeton Algorithm 4th Edition 课程说明课程内容数据处理，数学模型，算法分析 非数值问题： 数据结构：线性表，栈，队列，串，树，图 非数值算法：查找，排序 数值问题： 误差分析 线性方程组 非线性方程 拟合与插值 最优化初步 算法设计：蛮力，分治、减治、贪心、动态规划、搜索算法 绪论数据与算法数学模型对于现实世界的某一特定对象，为特定目的而得到的一个抽象的简">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://blitherboom812.github.io/images/DSA/Prim.jpg">
<meta property="og:image" content="https://blitherboom812.github.io/images/DSA/Kruskal.jpg">
<meta property="og:image" content="https://blitherboom812.github.io/images/DSA/Dijkstra.jpg">
<meta property="article:published_time" content="2022-09-13T02:01:08.000Z">
<meta property="article:modified_time" content="2023-01-22T08:53:13.000Z">
<meta property="article:author" content="Blither Boom">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blitherboom812.github.io/images/DSA/Prim.jpg"><script>(function() {
  if (CONFIG.mode !== 'auto') return
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches
  const setting = localStorage.getItem('darken-mode') || 'auto'
  if (setting === 'dark' || (prefersDark && setting !== 'light'))
    document.documentElement.classList.toggle('dark', true)
})()</script><!-- hexo injector head_end start --><link rel="stylesheet" type="text/css" href="/css/latex.css"><link rel="stylesheet" type="text/css" href="/css/fonts.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head><body><script src="https://code.iconify.design/2/2.1.1/iconify.min.js"></script><script>// Define global variable
IconifyProviders = {
  // Empty prefix: overwrite default API provider configuration
  '': {
    // Use custom API first, use Iconify public API as backup
    resources: [
        'https://api.iconify.design',
    ],
    // Wait for 1 second before switching API hosts
    rotate: 1000,
  },
};</script><script defer src="https://fastly.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js" type="module"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js" type="module"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><span class="icon iconify" data-icon="ri:list-ordered"></span></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><span class="icon iconify" data-icon="ri:passport-line"></span></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Blither Boom"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Blither Boom"></a><div class="site-author-name"><a href="/about/">Blither Boom</a></div><span class="site-name">Guo_Yun</span><sub class="site-subtitle"></sub><div class="site-description"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:home-4-line"></span></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:archive-line"></span></span><span class="site-state-item-count">32</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:folder-2-line"></span></span><span class="site-state-item-count">0</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="site-state-item-count">7</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><span class="icon iconify" data-icon="ri:settings-line"></span></span></a></nav><hr style="margin-bottom:0.5rem"><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><span class="icon iconify" data-icon="ri:genderless-line"></span></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><span class="icon iconify" data-icon="ri:contrast-2-line"></span></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E8%B5%84%E6%BA%90"><span class="toc-number">1.</span> <span class="toc-text">相关资源</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">课程说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9"><span class="toc-number">2.1.</span> <span class="toc-text">课程内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">3.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">数据与算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">数学模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.1.</span> <span class="toc-text">算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.</span> <span class="toc-text">算法分析和算法设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.1.</span> <span class="toc-text">算法及其特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7"><span class="toc-number">3.3.2.</span> <span class="toc-text">算法的评价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E6%80%A7"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">正确性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%A5%E5%A3%AE%E6%80%A7"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">健壮性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E6%80%A7"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">可读性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E6%95%88%E7%8E%87"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">高效率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E8%A1%A1%E9%87%8F%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">算法效率的衡量方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">渐进时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E4%BC%B0%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.3.1.1.</span> <span class="toc-text">算法效率估算方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E6%8C%87%E6%A0%87"><span class="toc-number">3.3.3.1.2.</span> <span class="toc-text">描述指标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%A4%A7-O-%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%B8%90%E8%BF%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E5%BB%BA%E7%AB%8B%E4%BA%86%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90%E7%9A%84%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.3.3.1.3.</span> <span class="toc-text">引入大 O 表示的渐进时间复杂度和空间复杂度实际上是建立了算法效率分析的数学模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%85%E9%80%9F%E6%89%BE%E5%88%B0%E4%BC%9A%E8%A2%AB%E5%A4%9A%E6%AC%A1%E5%8F%8D%E5%A4%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.3.1.4.</span> <span class="toc-text">迅速找到会被多次反复执行的基本操作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%BD%A2%E5%BC%8F%E9%9D%9E%E5%B8%B8%E6%9C%89%E9%99%90"><span class="toc-number">3.3.3.1.5.</span> <span class="toc-text">感兴趣的复杂度形式非常有限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%AF%B9%E6%95%B0%E5%9D%90%E6%A0%87%E7%94%BB%E5%9B%BE"><span class="toc-number">3.3.3.1.6.</span> <span class="toc-text">按照对数坐标画图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">空间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%A9%BA%E9%97%B4"><span class="toc-number">3.3.3.2.1.</span> <span class="toc-text">算法空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%B8%90%E8%BF%9B%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-S-n-x3D-O-f-n"><span class="toc-number">3.3.3.2.2.</span> <span class="toc-text">算法的渐进空间复杂度: $S(n) &#x3D; O[f(n)]$</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E6%89%80%E5%8D%A0%E7%A9%BA%E9%97%B4%E5%8F%AA%E5%8F%96%E5%86%B3%E4%BA%8E%E9%97%AE%E9%A2%98%E6%9C%AC%E8%BA%AB%EF%BC%8C%E5%92%8C%E7%AE%97%E6%B3%95%E6%97%A0%E5%85%B3%EF%BC%8C%E5%88%99%E5%8F%AA%E9%9C%80%E8%A6%81%E5%88%86%E6%9E%90%E8%BE%93%E5%85%A5%E5%92%8C%E7%A8%8B%E5%BA%8F%E4%B9%8B%E5%A4%96%E7%9A%84%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4"><span class="toc-number">3.3.3.2.3.</span> <span class="toc-text">输入数据所占空间只取决于问题本身，和算法无关，则只需要分析输入和程序之外的额外空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%92%8C%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">数据元素和数据项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%98%AF%E5%B8%A6%E7%BB%93%E6%9E%84%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">数据结构是带结构的数据元素的集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">二元关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.4.3.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.3.4.3.2.</span> <span class="toc-text">二元关系的性质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.4.3.3.</span> <span class="toc-text">常见的二元关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Data-Type"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">数据类型(Data Type)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-number">3.3.4.4.1.</span> <span class="toc-text">C 语言中的类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%94%A8%E6%9D%A5%E5%88%BB%E7%94%BB-%E7%A8%8B%E5%BA%8F-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">3.3.4.4.1.1.</span> <span class="toc-text">数据类型用来刻画(程序)操作对象的特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Abstract-Data-Type-ADT"><span class="toc-number">3.3.4.5.</span> <span class="toc-text">抽象数据类型(Abstract Data Type, ADT)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">3.3.4.6.</span> <span class="toc-text">抽象数据类型的描述</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8-ADT"><span class="toc-number">4.2.</span> <span class="toc-text">线性表 ADT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.3.</span> <span class="toc-text">单向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">双向链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-number">4.5.</span> <span class="toc-text">顺序表和链表的比较：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">4.6.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84ADT"><span class="toc-number">4.6.1.</span> <span class="toc-text">栈的ADT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.6.2.</span> <span class="toc-text">栈的表示和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">4.6.3.</span> <span class="toc-text">复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%94%E7%94%A8"><span class="toc-number">4.6.4.</span> <span class="toc-text">栈的一些应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">4.7.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">4.8.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.1.</span> <span class="toc-text">队列的表示和实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">4.9.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.9.1.</span> <span class="toc-text">匹配算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.10.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">4.10.1.</span> <span class="toc-text">树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">4.10.2.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">4.10.3.</span> <span class="toc-text">霍夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">4.10.4.</span> <span class="toc-text">二叉树的建立</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">4.11.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">4.11.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.11.2.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">4.11.3.</span> <span class="toc-text">生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91"><span class="toc-number">4.11.4.</span> <span class="toc-text">最短路径树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">4.11.4.1.</span> <span class="toc-text">单源最短路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">4.11.4.2.</span> <span class="toc-text">全源最短路径</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95-1"><span class="toc-number">5.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">非数值算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">5.1.1.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">查找表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">二叉搜索树（BST）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">散列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">数值算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">5.2.1.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3"><span class="toc-number">5.2.2.</span> <span class="toc-text">线性方程求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E6%B1%82%E8%A7%A3"><span class="toc-number">5.2.3.</span> <span class="toc-text">非线性方程求解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%9F%E5%90%88%E4%B8%8E%E6%8F%92%E5%80%BC"><span class="toc-number">5.2.4.</span> <span class="toc-text">拟合与插值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%9F%E5%90%88"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">拟合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%80%BC"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">插值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.5.</span> <span class="toc-text">优化问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">连续优化问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">5.3.</span> <span class="toc-text">算法设计思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">5.3.2.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9B%AE%E5%8A%9B%E6%B3%95"><span class="toc-number">5.3.3.</span> <span class="toc-text">蛮力法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">5.3.4.</span> <span class="toc-text">分治法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.5.</span> <span class="toc-text">搜索算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.6.</span> <span class="toc-text">随机算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.7.</span> <span class="toc-text">算法优化技术</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article" style="--smc-primary:#0078E7;"><link itemprop="mainEntityOfPage" href="https://blitherboom812.github.io/2022/09/13/DataAndAlgorithms/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Blither Boom"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Guo_Yun"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">笔记-数据与算法</h1><div class="post-meta"><div class="post-time"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-line"></span></span> <time title="Created: 2022-09-13 10:01:08" itemprop="dateCreated datePublished" datetime="2022-09-13T10:01:08+08:00">2022-09-13</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:calendar-2-line"></span></span> <time title="Modified: 2023-01-22 16:53:13" itemprop="dateModified" datetime="2023-01-22T16:53:13+08:00">2023-01-22</time></div><div class="post-classify"><span class="post-tag"><a class="tag-item" href="/tags/note/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><span class="icon iconify" data-icon="ri:price-tag-3-line"></span></span><span class="tag-name">note</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body"><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><p><a target="_blank" rel="noopener" href="https://algs4.cs.princeton.edu/home/">Princeton <em>Algorithm 4th Edition</em></a></p>
<h1 id="课程说明"><a href="#课程说明" class="headerlink" title="课程说明"></a>课程说明</h1><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><p>数据处理，数学模型，算法分析</p>
<p>非数值问题：</p>
<p>数据结构：线性表，栈，队列，串，树，图</p>
<p>非数值算法：查找，排序</p>
<p>数值问题：</p>
<p>误差分析</p>
<p>线性方程组</p>
<p>非线性方程</p>
<p>拟合与插值</p>
<p>最优化初步</p>
<p>算法设计：蛮力，分治、减治、贪心、动态规划、搜索算法</p>
<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><h2 id="数据与算法"><a href="#数据与算法" class="headerlink" title="数据与算法"></a>数据与算法</h2><h2 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h2><p>对于现实世界的某一特定对象，为特定目的而得到的一个抽象的简化的数学结构。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>算法是问题的程序化解决方案。</p>
<p>算法强调精确定义的求解过程，并不是问题的答案。</p>
<p>设计实现算法，并没有得到答案，但是给出了一般的解决方案。</p>
<p>一个算法能够解决很多看似好无关系的问题，只要这些问题可以抽象为某种相同的算法。</p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>数据是客观世界的描述。</p>
<p>数据是信息的载体，是算法处理的对象。</p>
<p>算法是处理数据的系统。</p>
<p>人的因素也被纳入了数学模型的和算法。</p>
<p>IBM Watson</p>
<h2 id="算法分析和算法设计"><a href="#算法分析和算法设计" class="headerlink" title="算法分析和算法设计"></a>算法分析和算法设计</h2><h3 id="算法及其特性"><a href="#算法及其特性" class="headerlink" title="算法及其特性"></a>算法及其特性</h3><p>算法的五个重要特性：</p>
<p>有穷性：一个算法必须可以在有穷步之后结束，且每一步可以在有穷时间内完成</p>
<p>确定性：算法的描述无歧义，算法的执行结果是确定的且精确地符合要求或期望</p>
<p>可行性：算法中描述的操作都可以通过已经实现的基本操作运算的有限次执行来实现</p>
<p>输入：一个算法有零个或多个输入，这些输入取自某个特定的对象集</p>
<p>输出：一个算法有一个或多个输出，输出量是算法计算的结果</p>
<h3 id="算法的评价"><a href="#算法的评价" class="headerlink" title="算法的评价"></a>算法的评价</h3><h4 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h4><p>不含语法错误</p>
<p>几组一般的输入数据</p>
<p>精心选择的、典型、苛刻且带有刁难性的输入数据（衡量标准）</p>
<p>一切合法的输入数据</p>
<h4 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h4><p>输入的数据非法</p>
<h4 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h4><p>描述清楚，便于理解</p>
<h4 id="高效率"><a href="#高效率" class="headerlink" title="高效率"></a>高效率</h4><p>占用的空间和时间资源</p>
<h3 id="算法效率的衡量方法"><a href="#算法效率的衡量方法" class="headerlink" title="算法效率的衡量方法"></a>算法效率的衡量方法</h3><p>和算法执行时间相关的因素有很多。</p>
<p>一个特定算法运行工作量的大小，是问题规模的函数。</p>
<h4 id="渐进时间复杂度"><a href="#渐进时间复杂度" class="headerlink" title="渐进时间复杂度"></a>渐进时间复杂度</h4><p>算法的渐进时间复杂度(Time Complexity): $T(n) &#x3D; O[f(n)]$</p>
<p>Big-O 记号的形式化定义</p>
<ul>
<li>若 f(n)是正整数 n 的一个函数，则$x_n &#x3D; O[f(n)]$表示存在正的常数$M$和$n_0$， 使得当$n &gt; n_0$时，都满足$|x_n| \le M|f(n)|$</li>
<li>标记的是算法效率的上限</li>
</ul>
<h5 id="算法效率估算方法"><a href="#算法效率估算方法" class="headerlink" title="算法效率估算方法"></a>算法效率估算方法</h5><ul>
<li>算法执行的时间 &#x3D; Σ 操作的执行次数 × 操作的执行时间</li>
<li>算法操作包括<strong>控制操作</strong>和<strong>原操作</strong><br>一般来说，相比于循环体，控制操作本身的复杂度可被忽略。而在原操作中，我们又可以寻找其中执行次数最多的一种或几种操作，这些操作被称为基本操作。</li>
<li>选取算法中的<strong>基本操作</strong></li>
<li>算法的执行时间与<strong>基本操作执行次数之和</strong>成正比</li>
</ul>
<h5 id="描述指标"><a href="#描述指标" class="headerlink" title="描述指标"></a>描述指标</h5><ul>
<li>最好情况(best-case)：对于任何一个输入的运行时间下限</li>
<li>最坏情况(worst-case)：对于任何一个输入的运行时间下限</li>
<li>平均(average-complexity): 根据各种操作出现概率的分布进行加权平均</li>
<li>分摊(amortized complexity): 连续实施足够多次操作，总成本摊至单次操作</li>
</ul>
<p>最重要的是平均情况下的性能</p>
<h5 id="引入大-O-表示的渐进时间复杂度和空间复杂度实际上是建立了算法效率分析的数学模型"><a href="#引入大-O-表示的渐进时间复杂度和空间复杂度实际上是建立了算法效率分析的数学模型" class="headerlink" title="引入大 O 表示的渐进时间复杂度和空间复杂度实际上是建立了算法效率分析的数学模型"></a>引入大 O 表示的渐进时间复杂度和空间复杂度实际上是建立了算法效率分析的数学模型</h5><h5 id="迅速找到会被多次反复执行的基本操作"><a href="#迅速找到会被多次反复执行的基本操作" class="headerlink" title="迅速找到会被多次反复执行的基本操作"></a>迅速找到会被多次反复执行的基本操作</h5><h5 id="感兴趣的复杂度形式非常有限"><a href="#感兴趣的复杂度形式非常有限" class="headerlink" title="感兴趣的复杂度形式非常有限"></a>感兴趣的复杂度形式非常有限</h5><h5 id="按照对数坐标画图"><a href="#按照对数坐标画图" class="headerlink" title="按照对数坐标画图"></a>按照对数坐标画图</h5><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><h5 id="算法空间"><a href="#算法空间" class="headerlink" title="算法空间"></a>算法空间</h5><ul>
<li>指令空间(instruction space): 用来存储程序指令所需的空间</li>
<li>数据空间(data space): 存储运行过程中常量和变量所需的空间</li>
<li>环境空间: 系统为程序运行，特别是函数调用提供的空间</li>
</ul>
<h5 id="算法的渐进空间复杂度-S-n-x3D-O-f-n"><a href="#算法的渐进空间复杂度-S-n-x3D-O-f-n" class="headerlink" title="算法的渐进空间复杂度: $S(n) &#x3D; O[f(n)]$"></a>算法的渐进空间复杂度: $S(n) &#x3D; O[f(n)]$</h5><h5 id="输入数据所占空间只取决于问题本身，和算法无关，则只需要分析输入和程序之外的额外空间"><a href="#输入数据所占空间只取决于问题本身，和算法无关，则只需要分析输入和程序之外的额外空间" class="headerlink" title="输入数据所占空间只取决于问题本身，和算法无关，则只需要分析输入和程序之外的额外空间"></a>输入数据所占空间只取决于问题本身，和算法无关，则只需要分析输入和程序之外的额外空间</h5><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="数据元素和数据项"><a href="#数据元素和数据项" class="headerlink" title="数据元素和数据项"></a>数据元素和数据项</h4><p>数据元素(Data Element): 数据的最小单位</p>
<p>数据项：(Data Item): 数据结构中讨论的最小单位</p>
<h4 id="数据结构是带结构的数据元素的集合"><a href="#数据结构是带结构的数据元素的集合" class="headerlink" title="数据结构是带结构的数据元素的集合"></a>数据结构是带结构的数据元素的集合</h4><p>逻辑结构：集合，线性结构，树结构，图结构</p>
<p>存储结构：顺序存储，链式存储</p>
<h4 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>定义：设有几何$M, N$, 其笛卡尔积$M \times N$的任意一个子集$R \in M \times N$</p>
<p>二元关系表示了集合$M$和集合$N$中元素之间的某种相关性。</p>
<p>若$(a, b) \in R$, 则称$a$为$R$的前件，$b$称为$R$的后件。</p>
<p>若$M &#x3D; N$, 则称$R \sub M \times M$为 M 上的二元关系。</p>
<h5 id="二元关系的性质"><a href="#二元关系的性质" class="headerlink" title="二元关系的性质"></a>二元关系的性质</h5><p>设$R$为集合$M$上的一个二元关系：</p>
<p>(1) 自反性：对于每个$a \in M$, 有 $(a, a) \in R$;</p>
<p>反自反性： 对于所有$a \in M$, 有$(a, a) \notin R$;</p>
<p>(2) 对称性：当$(a, b) \in R$时，则$a &#x3D; b$;</p>
<p>反对称性：当$(a, b) \in R$且$(b, a) \in R$时，必有$a &#x3D; b$;</p>
<p>(3) 传递性： 当$(a, b) \in R$且$(b, c) \in R$ 时， 必有$(a, c) \in R$。</p>
<h5 id="常见的二元关系"><a href="#常见的二元关系" class="headerlink" title="常见的二元关系"></a>常见的二元关系</h5><p>等价关系：满足自反性、对称性、传递性</p>
<p>偏序关系：满足自反性、反对称性、传递性</p>
<p>全序关系：若$M$中的任意两个元素$a$和$b$是可比的，也就是说或者有$aRb$成立，或者有$bRa$成立，则称$R$是集合$M$上的全序关系(Totala Order Relation)</p>
<h4 id="数据类型-Data-Type"><a href="#数据类型-Data-Type" class="headerlink" title="数据类型(Data Type)"></a>数据类型(Data Type)</h4><h5 id="C-语言中的类型定义"><a href="#C-语言中的类型定义" class="headerlink" title="C 语言中的类型定义"></a>C 语言中的类型定义</h5><p>五种基本数据类型：字符型，整型，浮点型，双精度浮点型和无值类型</p>
<p>程序中任何变量，常量都必须先定义类型。</p>
<p>整数类型 int 及定义在其上的操作：+, -, *, &#x2F;, %, ++, –</p>
<p>双精度浮点型 double 及定义在其上的操作：+, -, *, &#x2F;, ++, –</p>
<h6 id="数据类型用来刻画-程序-操作对象的特性"><a href="#数据类型用来刻画-程序-操作对象的特性" class="headerlink" title="数据类型用来刻画(程序)操作对象的特性"></a>数据类型用来刻画(程序)操作对象的特性</h6><p>数据类型是一个元素的集合和定义在此集合上的一组操作的总称。</p>
<p>数据类型实现了信息的隐藏，把一切用户无需了解的细节封装在类型中。</p>
<p>高级语言中的数据类型分为原子类型和结构类型。</p>
<h4 id="抽象数据类型-Abstract-Data-Type-ADT"><a href="#抽象数据类型-Abstract-Data-Type-ADT" class="headerlink" title="抽象数据类型(Abstract Data Type, ADT)"></a>抽象数据类型(Abstract Data Type, ADT)</h4><p>是指一个数学模型以及定义在此数学模型上的一组操作。</p>
<p>数据抽象：描述的是实体的本质特征、功能以及外部用户接口</p>
<p>数据封装：将实体的外部特性和内在实现细节发呢里，对外部用户隐藏内部实现细节，使得应用和实现分离</p>
<p>ADT 的优点：</p>
<ul>
<li>程序结构清晰，易于扩展易于维护而不失其效率</li>
<li>提高程序的数据安全性</li>
<li>大大增加了软件的复用程度</li>
</ul>
<h4 id="抽象数据类型的描述"><a href="#抽象数据类型的描述" class="headerlink" title="抽象数据类型的描述"></a>抽象数据类型的描述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名&#123;</span><br><span class="line">    数据对象: &lt;数据对象的定义&gt;</span><br><span class="line">    数据关系: &lt;数据关系的定义&gt;</span><br><span class="line">    基本操作: &lt;基本操作的定义&gt;</span><br><span class="line">    基本操作名(参数表)</span><br><span class="line">        初始条件: &lt;初始条件描述&gt;</span><br><span class="line">        操作结果: &lt;操作结果描述&gt;</span><br><span class="line">&#125;ADT 抽象数据类型名</span><br></pre></td></tr></table></figure>

<p>基本操作参数:</p>
<ul>
<li>赋值参数提供输入值</li>
<li>引用参数以&amp;打头，用于返回操作结果</li>
</ul>
<h1 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表的元素可以是各种各样的，但是同一线性表的元素必然具有相同特性-同质</p>
<p>线性表中的相邻元素之间存在有序关系-位序</p>
<p>线性表是一种“有序结果”，即在数据元素的非空有限集合中</p>
<ul>
<li>存在唯一的一个被称为“第一个”的数据元素，无前驱；</li>
<li>存在唯一的一个被称为的“最后一个”的数据元素，无后继；</li>
<li>除第一个之外，每一个数据元素均只有一个直接前驱；</li>
<li>除最后一个之外，每个数据元素均只有一个直接后继</li>
</ul>
<p>线性表中元素个数定义为线性表的长度</p>
<div>$$(a\_0, a\_1, \dots, a\_{i-1}, a\_i, a\_{i+1}, \dots, a\_{n-1})$$</div>

<p>若线性表为空，则其长度为 0，称为空表</p>
<p>在非空表中，每个数据元素都有一个确定的位置</p>
<ul>
<li>$a_0$是第 0 个数据元素，$a_{n-1}$是第$n-1$个数据元素</li>
<li>$a_i$是第 i 个数据元素</li>
<li>称 i 为数据元素$a_i$在线性表中的位序</li>
</ul>
<h2 id="线性表-ADT"><a href="#线性表-ADT" class="headerlink" title="线性表 ADT"></a>线性表 ADT</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ADT List&#123;</span><br><span class="line">    数据对象:</span><br><span class="line">    数据关系:</span><br><span class="line">    基本操作：</span><br><span class="line">    InitList(&amp;L);</span><br><span class="line">        操作结果：构造一个空的线性表L。</span><br><span class="line">    DestroyList(&amp;L);</span><br><span class="line">        初始条件：线性表已存在。</span><br><span class="line">        操作结果：销毁线性表L。</span><br><span class="line">    IsEmpty(L);</span><br><span class="line">        初始条件：线性表已存在。</span><br><span class="line">        操作结果：若L为空表，则返回TRUE，否则返回FALSE。</span><br><span class="line">    ListLength(L);</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：用e返回L中第i个数据元素的值</span><br><span class="line">    GetElem(L, i, &amp;e);</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果；用e返回L中第i个数据元素的值。</span><br><span class="line">    LocateElem(L, e, compare());</span><br><span class="line">        初始条件：线性表L已存在，compare()是数据元素判定函数。</span><br><span class="line">        操作结果：返回L中第<span class="number">1</span>个与e满足关系compare()的数据元素的位序。若这样的元素不存在，则返回-<span class="number">1</span>。</span><br><span class="line">    PriorElem(L, cur_e, &amp;pre_e);</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。</span><br><span class="line">    ClearList(&amp;L);</span><br><span class="line">        初始条件：线性表L已存在；</span><br><span class="line">        操作结果：将L重置为空表。</span><br><span class="line">    ListInsert(&amp;L, i, e);</span><br><span class="line">        初始条件：线性表L已存在, <span class="number">0</span> &lt;=i &lt;= ListLength(L)。</span><br><span class="line">        操作结果：在L中第i个位置插入新的数据元素e，L的长度加<span class="number">1</span>。</span><br><span class="line">    ListDelete(&amp;L, i, &amp;e)</span><br><span class="line">        初始条件：线性表L已存在，<span class="number">0</span> &lt;= i &lt;= ListLength(L) - <span class="number">1</span>。</span><br><span class="line">        操作结果：删除L的第i个数据元素，用e返回其值，L的长度减<span class="number">1</span>。</span><br><span class="line">    ListTraverse(L, visit());</span><br><span class="line">        初始条件：线性表L已存在。</span><br><span class="line">        操作结果：依次对L的每个数据元素调用函数 visit()。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>线性表的合并：$O(m+n)$</p>
<p>线性表的保序归并：$O(m+n)$</p>
<p>线性表的顺序存储：顺序表</p>
<ul>
<li>用一组地址连续的存储单元依次存储线性表的数据元素</li>
</ul>
<p>顺序表的主要操作：</p>
<p>插入操作：在顺序表的第 i 个位置插入一个新元素，使顺序表的长度增加到$n+1$</p>
<p>复杂度分析：</p>
<ul>
<li>在顺序表的第$i$个位置插入一个新元素，需要移动$n - i$个元素；</li>
<li>假设从顺序表的第$i$个位置插入元素的先验概率为$p_i$</li>
<li>插入操作移动元素次数的期望为$E_{insert} &#x3D; \sum_{i &#x3D; 0}^n(n - i) \times p_i$</li>
</ul>
<p>删除操作：把顺序表的第$i$个位置的元素从表中删除，使长度为$n$的顺序表的长度变为$n - 1$</p>
<p>复杂度分析：</p>
<ul>
<li>把顺序表的第$i$个位置上的元素删除，需要移动$n - i -1$个元素</li>
<li>假设从顺序表的第$i$个位置删除元素的先验概率为$q_i$</li>
<li>删除操作移动元素次数的期望为: $E_{delete} &#x3D; \sum_{i &#x3D; 0}^{n - 1}(n - i - 1) \times q_i$</li>
</ul>
<p>不失一般性，我们假设插入或删除元素出现在任何位置的概率都是相等的，因此有$p_i &#x3D; p &#x3D; 1&#x2F;(n+1), q_i &#x3D; q &#x3D; 1&#x2F;n$。</p>
<p>推导得到：</p>
<div>$$E\_{insert} = \frac1{n+1}\sum\_{i = 0}^n(n-i) = \frac n2\newline E\_{delete} = \frac1n\sum\_{i = 0}^{n - 1}(n - i - 1) = \frac{n - 1}2$$</div>

<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p>最简单的链表结构：链表节点(node)由两个域组成。</p>
<p>数据域：存储数据元素，</p>
<p>指针域：指向直接后继节点</p>
<p>单向链表的 C++实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NODE *head;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LinkList</span>() &#123;head = <span class="literal">NULL</span>;&#125;</span><br><span class="line">    ~<span class="built_in">LinkList</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">clearSqList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> head ==  <span class="literal">NULL</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">GetElem</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> *e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(<span class="type">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PriorElem</span><span class="params">(<span class="type">int</span> cur_e, <span class="type">int</span> *next_e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">NextElem</span><span class="params">(<span class="type">int</span> cur_e, <span class="type">int</span>* pre_e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> *e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Traverse</span><span class="params">(<span class="type">bool</span> (*visit)(<span class="type">int</span> e))</span></span>;<span class="comment">//遍历所有节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单向链表的不足：</p>
<ul>
<li>单链表的表长是一个隐含的值，遍历链表才能得到</li>
<li>在单链表中插入或者删除元素时，需要在链表中依序寻找操作位置</li>
<li>在链表中，元素的“位序”概念淡化，结点的“位置”概念强化</li>
<li>如何得到某个元素的前驱？</li>
</ul>
<p>改进链表的设置：</p>
<ul>
<li><p>增加“表长”、“表尾指针”和“当前位置指针”三个数据域</p>
</li>
<li><p>将基本操作中的“位序i”改为“指针p”</p>
</li>
</ul>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>由数据，前驱和后继构成。</p>
<p>方便寻找前驱，但是增加了维护成本。</p>
<h2 id="顺序表和链表的比较："><a href="#顺序表和链表的比较：" class="headerlink" title="顺序表和链表的比较："></a>顺序表和链表的比较：</h2><p>顺序表</p>
<p>用一组地址连续的存储单元依次存储线性表中的数据元素</p>
<p>优点：可以随机存取</p>
<p>缺点：插入，删除操作需要移动表中的数据元素，事先确定规模，空间效率不高。</p>
<p>链表：</p>
<p>用一组“任意”的存储单元（附加指针）存储表中的数据元素</p>
<p>优点：插入，删除操作无需移动表中的数据元素，空间利用率高</p>
<p>缺点：不能随机存取</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是LIFO(Last In First Out，先进后出)的线性表。</p>
<p>允许插入和删除的一段称为栈顶(top), 另一端称为栈底(bottom)</p>
<h3 id="栈的ADT"><a href="#栈的ADT" class="headerlink" title="栈的ADT"></a>栈的ADT</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Push</span>(&amp;s, e);</span><br><span class="line">    <span class="built_in">Pop</span>(&amp;s, &amp;e);</span><br><span class="line">    <span class="built_in">ClearStack</span>(&amp;s);</span><br><span class="line">&#125; ADT Stack;</span><br></pre></td></tr></table></figure>

<h3 id="栈的表示和实现"><a href="#栈的表示和实现" class="headerlink" title="栈的表示和实现"></a>栈的表示和实现</h3><p>栈的顺序表示</p>
<p>top指向最后一个元素可以，指向空也可以，但是实现时要自洽。</p>
<p>栈的链式表示</p>
<p>有头插入和尾插入两个方式</p>
<p>总体来看，头插入比尾插入的优势要更大。首先，插入时虽然头插入要修改的指针更多，但是时间复杂度小，头插入$O(1)$，尾插入$O(n)$。其次，如果以尾部为栈顶，删除时会很麻烦。</p>
<p><strong>静态分配</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_MAX_SIZE 100</span></span><br></pre></td></tr></table></figure>
<p><strong>动态分配</strong></p>
<p>程序隐含设定</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_INT_SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACKINCREMENT 10</span></span><br></pre></td></tr></table></figure>

<p>用户给定</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>顺序栈的效率分析</p>
<p>时间复杂度</p>
<ul>
<li>进栈、出栈:$O(1)$</li>
<li>栈的溢出处理</li>
<li>如果栈元素时简单数据类型，则构造和销毁函数也是$O(1)$的</li>
</ul>
<p>空间复杂度</p>
<ul>
<li>顺序栈的长度构造时确定</li>
<li>空间利用效率低</li>
</ul>
<p>链式栈的效率分析</p>
<p>时间复杂度</p>
<ul>
<li>链式栈的入栈出栈是$O(1)$时间的</li>
<li>建立和销毁是$O(n)$时间的</li>
</ul>
<p>空间复杂度</p>
<ul>
<li>一般不会产生溢出</li>
<li>空间利用率高</li>
</ul>
<h3 id="栈的一些应用"><a href="#栈的一些应用" class="headerlink" title="栈的一些应用"></a>栈的一些应用</h3><p>显式应用：括号匹配，表达式求值，迷宫求解</p>
<p>隐式应用：函数调用，递归</p>
<p>系统栈</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>栈与递归具有相似性。</p>
<p>Fibonacci的递归次数：$C(n) &#x3D; O(t^n)$</p>
<p>(证明思路：归纳法证明$C(n) &#x3D; 2F(n) - 1$, 根据F(n)通项可以判断。)</p>
<p>使用递推法的时间复杂度：$O(n)$.</p>
<p>经常需要进行递归的消除。消除方法：递推，循环等，没有统一的解决方案。可以借用显式栈实现非递归过程。</p>
<p>递归的评价：</p>
<ul>
<li>简洁，便于理解，便于叙述和设计</li>
<li>运行效率低，无法控制递归堆栈的规模</li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是FIFO(First In First Out, 先进先出)的线性表。</p>
<h3 id="队列的表示和实现"><a href="#队列的表示和实现" class="headerlink" title="队列的表示和实现"></a>队列的表示和实现</h3><p>队列的顺序表示法</p>
<p>入队: rear &#x3D; rear + 1</p>
<p>出队: front &#x3D; front + 1</p>
<p>需要判定队满和队空。</p>
<p>顺序队列的问题：被出队的空间不会再次被使用了。</p>
<p>循环队列：</p>
<p>队尾指针指向maxSize - 1时， 入列则指向0；</p>
<p>队头指针指向maxSize - 1，出列也指向0。</p>
<p>可以使用模运算实现。</p>
<p>缺点：无法区分队空和队满的状态。</p>
<p>区分方法：</p>
<p>设置一个空位；设置标志；设置队列长度变量</p>
<p>队列的链式表示法</p>
<p>入队不会出现队满的问题，出队可能回有队空的问题，队空的条件为front &#x3D; NULL.</p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串是有线长度的字符序列。</p>
<p>串的长度是字符个数。</p>
<p>字符在串中的位置。</p>
<p>两个串相等的条件。</p>
<p>子串和主串，子串在主串中的位置。</p>
<h3 id="匹配算法"><a href="#匹配算法" class="headerlink" title="匹配算法"></a>匹配算法</h3><p>Brute-Force算法：一个一个比。复杂度最高O(m * n)。</p>
<p>KMP算法：尽可能跳过更多不必要的匹配。复杂度最多O(m + n)。</p>
<p>Horspool算法：启发式算法。复杂度低则O(m&#x2F;n)，高则O(m * n + s)，s为字符表规模</p>
<p>Boyer-Moore算法：最坏O(n)。KMP和Horspool的综合（或者说Horspool是BM算法的简化版本。）</p>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>空树，子树。</p>
<p>结点（node）是树的基本单位。</p>
<p>结点的度(degree)：结点的子树个数。</p>
<p>树的度：结点度的最大值。</p>
<p>k叉树：树的度为k</p>
<p>child, parent, cousin, ancestor, descendant</p>
<p>depth&#x2F;height</p>
<p>树的性质：</p>
<ol>
<li>树中结点数等于所有结点度数和加一</li>
<li>k叉树第i层至多$k^{i - 1}个结点$</li>
<li>深度为h的k叉树至多有$(k^h - 1)&#x2F;(k - 1)$个结点</li>
<li>具有n个结点的k叉树的最小深度为$[\log_k(n(k - 1) + 1)]$</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是结点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。</p>
<p>二叉树的性质：</p>
<ol>
<li>叶子结点数 &#x3D; 度为二的结点数 + 1</li>
<li>第i层至多$2^{i - 1}$个结点</li>
<li>深度为h，则最多有$(2^h - 1)$个结点</li>
<li>具有n个结点的完全二叉树的深度为$\lceil\log_2(n + 1)\rceil$</li>
<li>对于完全二叉树（最后一层从右向左缺若干结点），从左向右，从上到下编号，则$\lfloor(i - 1)&#x2F;2\rfloor$为编号i的parent结点，$2i + 1$为其左子树，$2i + 2$为其右子树。</li>
</ol>
<p>二叉树的顺序表示</p>
<p>完全二叉树按照编号存储。不完全二叉树按照它对应的完全二叉树存储，但是缺少的部分留空。</p>
<p>不完全二叉树结点越少，空间效率越低。</p>
<p>二叉树的链式表示</p>
<p>空间效率很高。</p>
<p>二叉树的遍历：</p>
<p>记根节点为V，遍历左子树为L，遍历右子树记为R</p>
<p>先序遍历：V - L - R</p>
<p>中序遍历：L - V - R</p>
<p>后序遍历：L - R - V</p>
<p>遍历可以通过递归实现，但是递归可能会对效率产生影响。可以利用栈的特性实现遍历。</p>
<p>层序遍历：从上到下优先遍历同一层的结点。</p>
<p>遍历实现了树的线索化过程。</p>
<h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>霍夫曼树：寻找加权路径长度(WPL)的最小树。</p>
<p>用途：实现性能最好的变长二进制编码。</p>
<p>霍夫曼编码不是唯一的，但是所有霍夫曼树的WPL都相等。</p>
<p>不足：</p>
<p>没有错误保护功能</p>
<h3 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h3><p>只知道二叉树的先序序列，不能确定这棵二叉树。</p>
<p>但是如果同时知道先序序列和中序序列，则可以确定这棵二叉树。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>图的定义</p>
<p>顶点，边，弧</p>
<p>邻接顶点</p>
<p>有向图，无向图</p>
<p>有向完全图，无向完全图</p>
<p>子图</p>
<p>握手定理，度</p>
<p>权，网络<br>边上的数叫做权。有权的图叫网络。</p>
<p>连通</p>
<p>连通图</p>
<p>连通分量<br>无向图的极大连通子图为连通分量。（所谓极大，就是再加入一个点都会导致它不连通）</p>
<p>强连通图<br>有向图中存在vi到vj且存在vj到vi的图。</p>
<p>强连通分量<br>有向图的极大强连通子图为强连通分量。</p>
<p>Euler路径和Euler回路</p>
<p>图的存储和表示</p>
<p>邻接矩阵表示<br>如果v和w之间有边，则元素为1，否则为0.</p>
<p>邻接表表示<br>采用链表数组表示图。同一个顶点发出的边在同一个链表中。</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>深度优先遍历和广度优先遍历</p>
<p>图的遍历：从已给连通图的某一顶点出发，沿着一些边访问所有顶点，且每个顶点只访问一次，则叫做图的遍历。</p>
<p>邻接矩阵的遍历：$O(v^2)$</p>
<p>邻接表的遍历：$O(v + e)$</p>
<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>连通图的生成树，包含图中全部n个顶点，但只有n-1条边。</p>
<p>深度优先和广度优先遍历分别会得到一个搜索树。</p>
<p>最小生成树：权值之和最小的生成树。</p>
<p>求最小生成树的算法：贪心算法思想。Kruskal算法和Prim算法。</p>
<p>Prim算法</p>
<p><img src="/../images/DSA/Prim.jpg" loading="lazy"></p>
<p>Prim算法的时间复杂度为$O(n^2)$。对稠密图而言是线性的。对于稠密图而言，Prim的邻接矩阵实现是首选方法。</p>
<p>Kruskal算法<br><img src="/../images/DSA/Kruskal.jpg" loading="lazy"></p>
<p>Kruskal的时间复杂度为$O(E\log E)$。</p>
<p>Kruskal算法对于稀疏图是好的选择。</p>
<h3 id="最短路径树"><a href="#最短路径树" class="headerlink" title="最短路径树"></a>最短路径树</h3><p>从根到其他顶点的最短路径</p>
<p>源点-汇点最短路径：给定一个起始顶点s和一个结束顶点 ，在图中找出从s到t的一条路径。起始顶点称为“源点”，结束顶点称为“汇点”</p>
<p>单源最短路径：给定一个起始顶点s，找出从s到图中其它各顶点的最短路径</p>
<p>全源最短路径：找出连接图中各对顶点的最短路径</p>
<h4 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h4><p>Dijkstra算法</p>
<p><img src="/../images/DSA/Dijkstra.jpg" loading="lazy"></p>
<p>Dijkstra算法通过构造加权有向图图的最短路径树SPT，来实现单源最短路径算法。</p>
<p>时间复杂度为$O(v^2)$，和Prim算法很相似。</p>
<h4 id="全源最短路径"><a href="#全源最短路径" class="headerlink" title="全源最短路径"></a>全源最短路径</h4><p>可以对每个顶点用Dijkstra算法。</p>
<p>Floyd算法</p>
<p>时间复杂度：$O(v^3)$。可以计算出一个网络中所有的最短路径。</p>
<p>Floyd算法允许图中带有负权值的边，但不允许有包含带负权值的边组成回路。</p>
<h1 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h1><h2 id="非数值算法"><a href="#非数值算法" class="headerlink" title="非数值算法"></a>非数值算法</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>查找算法的复杂性：关键字&#x2F;数据规模</p>
<p>查找算法的分类：</p>
<ul>
<li>内部&#x2F;外部</li>
<li>静态&#x2F;动态</li>
</ul>
<h4 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h4><p>查找表（Search Table）是由同一类型数据元素构成的集合。</p>
<p>按关键字查找</p>
<ol>
<li>查询某元素是否存在</li>
<li>检索某数据元素的各种属性</li>
<li>在查找表中插入一个数据元素</li>
<li>从查找表中删除一个数据元素</li>
</ol>
<p>查找表的种类</p>
<ol>
<li>静态查找表-仅可执行1,2</li>
<li>可执行1,2,3,4</li>
</ol>
<p>平均查找长度：在查找过程中，为确定目标在查找表中的位置，需要进行关键字比较次数的期望值</p>
<div>$$
ASL = \sum_{0}^{n - 1}P_i C_i
$$</div>

<p>$P_i$为第i条记录的查找概率，$C_i$为第i条记录的查找长度。</p>
<p>有时我们会假设查找概率相等或不等，有时要考虑查找失败的比较次数。</p>
<p>ASL越小，查找性能越好。</p>
<p>顺序查找：又称线性查找，是从线性<br>表的一端开始，依次把每个元素的<br>关键字同给定值进行比较</p>
<p>假设每个元素的查找概率相等，则平均查找长度为：$ASL &#x3D; \sum_0^{n - 1}\frac{i + 1}{n} &#x3D; \frac{n + 1}{2}$。</p>
<p>更多考虑：查找概率不等；查找失败需要N次比较；越界判断</p>
<p>折半查找：如果顺序表有序，我们可以采用高效率的折半查找</p>
<p>折半查找可以用一个二叉树结构来表述。比较次数不会超过$\lfloor\log_2 N + 1\rfloor$。</p>
<p>索引查找：将线性表划分为若干子表，再建立指向这若干子表的一个索引表。相同性质的数据归类到一个子表中。</p>
<p>索引表：顺序表或链表</p>
<p>子表：顺序表或链表</p>
<p>因而可以有四种不同的索引存储方式。</p>
<p>索引表的特点：表不大， 表中元素不常变动。因而适合用顺序表来表示索引表。</p>
<p>分块查找：也称索引顺序查找，是顺序查找的改进。子表之间有序；块内元素无序。索引表包括关键字项，指针项，子表长度。</p>
<p>索引文件：单关键字，多关键字。</p>
<p>稠密索引：索引表的索引项和主文件的各记录一一对应，称为稠密索引。</p>
<p>稀疏索引（非稠密索引）：索引项对应主文件的一部分记录。</p>
<p>索引文件的好处：减少访问外存的次数，提高查找速度。</p>
<p>倒排文件：不同之处是辅索引表包含物理地址序列。（为什么要倒排？）</p>
<h4 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h4><p>或者是一棵空树，或者是具有下列性质<br>的二叉树：每个结点有一个关键字(key)，<br>并且:</p>
<ol>
<li>任意结点关键字大于等于该结点左<br>子树中所有结点含有的关键字</li>
<li>同时该结点的关键字小于等于右子<br>树中所有结点含有的关键字</li>
</ol>
<p>BST是一种重要的动态搜索结构。它的中序遍历是确定的。 </p>
<p>BST的插入操作和查找操作同样简单。</p>
<p>删除操作比较复杂。叶子结点的删除比较简单；如果结点只有一棵子树，也比较简单；如果左右子树都不空，可以用中序后继替换。</p>
<p>BST的性能：越“平衡”越好。</p>
<p>二叉搜索树的路径长度和高度直接关系到BST中搜索的开销，对于一棵<br>含有N个关键字的BST</p>
<ul>
<li>最好情况下，所有搜索都可以保证对数运行时间</li>
<li>最坏情况下，进行一次搜索需要 次比较</li>
<li>平均情况下搜索需要 次比较操作</li>
</ul>
<p>BST的旋转操作：结点和一个子孙交换角色。分为左旋转和右旋转。右旋转涉及到结点和右孩子。（右旋转和左旋转是以结点自己作为参考系而言。）</p>
<p>BST通过不断的旋转来保证自己的平衡性。</p>
<p>AVL树：<br>一棵AVL树或者是空树，或者是具有下列性质的二叉搜索树:</p>
<ol>
<li>左子树和右子树都是AVL树</li>
<li>且左子树和右子树的高度之差的绝对<br>值不超过1</li>
</ol>
<p>AVL的高度为$O(\log_2 n)$，平均查找长度也为$O(\log_2 n)$。</p>
<p>AVL具有良好的搜索性能，能够避免一般BST性能恶化的问题。但是AVL的维护比较复杂，在进行插入和删除操作后，都必须通过大量的旋转操作保证AVL的平衡性。</p>
<p>寻找其他方法，以提高BST的平衡程度，保证BST的性能。</p>
<ul>
<li><p>实用的平衡二叉搜索树-红黑树</p>
</li>
<li><p>多路平衡的动态查找结构-B-树</p>
</li>
</ul>
<h4 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h4><p>散列的关键是散列函数和冲突处理。</p>
<p>散列函数应是简单的，能在较短的时间内计算出结果</p>
<p>散列函数的定义域必须包括需要存储的全部关键码，如果散列表允许有m<br>个地址，其值域必须在0到m-1之间</p>
<p>理想的散列函数应近似为随机的，对每一个输入，相应的输出在值域上是<br>等概的。</p>
<p>冲突处理：</p>
<ul>
<li>链地址法：把散列到同一个地址的关键字存进链表中。（表长小于元素数目）</li>
<li>开放定址法：放在表中空的位置。查找时采用“探测”的方法。如果探测下一个位置，称为线性探测。（表长大于元素数目，稀疏表，一般不允许表达到半满状态）</li>
<li>双重散列法：用第二个散列函数表达散列的增量。时间复杂度略大，但是性能比线性探测好很多。</li>
</ul>
<p>散列的其他应用：字符串的匹配；搜索引擎对URL的散列；信息安全中的内容鉴别技术（MD5, sha）。</p>
<p>散列提供常数时间的查找性能，实现简单；但是好的散列函数不易找到，删除操作和空间性能不好，最坏情况下性能不好，忽略了数据间的逻辑关系。</p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序算法的稳定性：如果两个对象的排序码相等，排序前后的顺序不变，则是稳定的；否则是不稳定的。</p>
<p>内排序：数据对象存放在内存。</p>
<p>外排序：数据对象在内、外存之间移动。</p>
<p>冒泡排序：复杂度为$O(n^2)$。添加排序标记，最好情况下只需要$n - 1$次比较和0次交换。</p>
<p>插入排序：有直接插入，折半插入，希尔排序</p>
<p>直接插入：$O(n^2)$</p>
<p>折半插入：查找插入位置的时候可以采用折半查找，因为表中可以插入的部分已经排好序了。复杂度没有变化，依然是$O(n^2)$</p>
<p>希尔排序：如果序列中，间距为h的元素都有序，称这个序列为h-排序的。希尔排序就是不断缩小h，直到h&#x3D;1。</p>
<p>选择特定的步长序列$h_n$，取出序列中增量为$h_n$的子列进行插入排序。然后取$h_{n-1}$，直至取$h_1&#x3D;1$。</p>
<p>它在h比较大的时候排序，由于间距短，速度快；而h小的时候，由于有序性强，速度快。总体速度依赖于步长序列的选择，时间复杂度比直接插入好一些。</p>
<p>选择排序：比较次数$O(n^2)$，移动次数$O(n)$，移动次数少一些。</p>
<p>冒泡排序和插入排序都是稳定的，而选择排序是不稳定的。</p>
<p><strong>快速排序</strong>：一种交换类排序。具有很好的性能。</p>
<p>将待排序序列分为两个部分，满足：</p>
<ol>
<li>a[i]位于它在序列中的正确位置</li>
<li>前面的元素比a[i]小</li>
<li>后面的元素比a[i]大<br>然后对两个部分继续划分，每次划分都将一个元素划分到它的正确位置。</li>
</ol>
<p>如何划分：</p>
<p>选择划分元素v。从序列左边扫描，找到一个比v大的元素，从右边扫描，找到一个比v小的元素，交换两个元素。反复交换，直到左右扫描指针相遇，则划分完成。</p>
<p>快速排序的递归树是一颗二叉搜索树，因为每次递归都是对比自己大和比自己小的两个部分递归。</p>
<p>时间复杂度：理想情况下$O(N\log_2N)$，如果递归树是平衡的。平均情况下为$O(N\log N)$，而最坏情况下退化为$O(N^2)$。</p>
<p>快速排序是不稳定的排序算法。</p>
<p>改进：</p>
<p>划分元素是最大或者最小的元素时是最坏情况。为了避免最坏情况，采用中间元素法：取序列的左端元素，右端元素和中间元素，选择关键字处于中间的元素作为划分元素。</p>
<p>快速排序中，子序列非常小时仍然要递归调用，可以采用插入排序代替，提高效率。</p>
<p>归并排序：合并有序表。两个表的归并，叫二路归并。利用二路归并可以实现归并排序。</p>
<p>自底向上归并：将文件分割成长度为m的子序列，每次m翻倍。</p>
<p>自顶向下归并：将文件分割为两个部分，分别进行递归的归并排序后再合起来进行归并排序。</p>
<p>归并排序是稳定的，时间最好情况是$O(N\log N)$，最坏是$O(N^2)$.</p>
<p>堆：堆是满足堆性质的完全二叉树。</p>
<p>最大堆：任意节点的值小于父节点的值。</p>
<p>最小堆；任意节点的值小于父节点的值。</p>
<p>因为是完全二叉树，适合用顺序存储方式。</p>
<p>堆：顺序存储在一维数组中。</p>
<p>堆的操作，例如插入，删除或者修改结点会破坏堆的性质，因此修复堆是重要的操作。</p>
<p>对于最大堆，如果某结点的关键值小于其子节点的关键值，可以采用自顶向下堆化(Heapify-down)的算法进行修复。</p>
<p>对于最大堆，若结点的关键值大于父节点的关键值，采用自底向上堆化(Heapify-up的算法进行修复)</p>
<p>向堆中插入结点：在新节点插入堆尾，调用自底向上算法调整堆。这种构造堆方法称为自顶向下的堆构造。</p>
<p>自顶向下的堆构造：$O(N\log N)$</p>
<p>自底向上的堆构造：时间复杂度$O(N)$</p>
<p>自底向上构造复杂度小的原因：离根远的复杂度小，离根近的复杂度大。而自顶向下是离根远的复杂度大，离根近的复杂度小。离根远的数量多，而离根近的数量少，因此自底向上的整体的复杂度更小。</p>
<p>优先级队列可以用堆实现，性能非常好。</p>
<p>堆排序：节约空间，比较次数和移动次数都是$O(N\log N)$。堆排序是不稳定的排序方法。</p>
<p>从小到大排序的方法：自底向上构造最大堆。将堆首与堆尾交换，堆序列长度-1，调整堆，再次交换，重复上述过程，直到堆空。</p>
<blockquote>
<p>堆排序大概可以理解成优先队列的出队过程。</p>
</blockquote>
<p>采用决策树的方法可以求得比较次数的下界为$O(N\log N)$</p>
<h2 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>一个数值问题是适定的(well posed)，需要满足：</p>
<ul>
<li>解存在</li>
<li>解唯一</li>
<li>连续地依赖于问题数据</li>
</ul>
<p>不满足条件的问题被称为不适定的(ill-posed)。</p>
<p>适定的问题，如果解对输入数据非常敏感，则称之为病态的(ill-conditioned)。</p>
<p>针对适定和良态(well-conditioned)问题，数值分析可以得到具有一定精度的近似解。</p>
<p>数值分析重视误差。误差&#x3D;计算误差+传播误差，算法影响的是计算误差。误差有模型误差、测量误差、截断误差、舍入误差。</p>
<p>前向误差反映了输出的误差，后向误差反映了输入的误差。相对前向误差与相对后向误差的比值叫做条件数(condition number)。$cond \le 1$说明问题是良态的；否则是病态的。</p>
<p>实际问题中我们通常求解条件数的估计值或者上限。进而求得前向误差。</p>
<p>相对条件数:$\left|\frac{xf^\prime (x)}{f(x)}\right|$。绝对条件数：$\left|f(x)\right|$</p>
<p>算法的稳定性：如果一个算法对于计算过程中的微小扰动不敏感，则算法是稳定的。</p>
<p>问题的病态性针对输入数据的微小扰动，而算法的稳定性针对的是计算过程中的误差。</p>
<p>最近舍入法：与x最相近的浮点数，如果相等，取最后一个存储位为偶数。</p>
<p>若是偶数，则区间是闭区间；若是奇数，则对应的区间为开区间。</p>
<p>浮点数的下溢限主要由尾数决定，机器精度由尾数决定。</p>
<p>浮点数的表示法:</p>
<div>$$
x = \pm \left(d_0 + \frac{d_1} \beta + \frac{d_2} {\beta^{2}}+ \dots + \frac{d_{p-1}} {\beta^{p-1} } \right)\beta^E
$$</div>

<p>在正规化浮点数系统中：</p>
<div>$$
\text{UFL}=\beta_L\\
\text{OFL}=\beta^{U+1}(1 - \beta^{1-p})\\
$$</div>

<p>机器精度：舍入造成的相对误差上限：</p>
<div>$$
\left|\frac{fl(x) - x}{x}\right| \le \epsilon_{mach}
$$</div>

<p>最近舍入方式下：</p>
<div>$$
\epsilon_{mach} = \beta^{1-p} / 2
$$</div>

<h3 id="线性方程求解"><a href="#线性方程求解" class="headerlink" title="线性方程求解"></a>线性方程求解</h3><p>解矩阵方程$A\mathbb x &#x3D; \mathbb b$。</p>
<p>误差分析：</p>
<p>条件数：$\text{cond}(A) &#x3D; ||A||||A^{-1}||$</p>
<p>直观理解：两条线接近平行的时候，两条线截距的轻微扰动会造成解很大的不确定性。</p>
<p>解方程：</p>
<p>直接求解法</p>
<p>高斯消元法：复杂度$O(n^3)$。通常采用列选主元的方法提高算法的稳定性。</p>
<p>LU分解：如果$b$变化而$A$不变，可以较快地多次求解。</p>
<p>解的精度分析：条件数大，即使残差很小，也会得出极大的计算误差。是因为问题本身非常敏感。</p>
<p>高斯-约当法：把A变换为对角阵。</p>
<p>乔列斯基分解：A是对称正定阵，则A&#x3D;LL’。</p>
<ul>
<li>算法是良态的</li>
<li>不需要选主元就有稳定性</li>
<li>只需要存储下三角部分即可</li>
<li>分解的乘法和加法次数都约为$n^3&#x2F;6$</li>
</ul>
<p>线性方程的迭代解法：</p>
<p>不动点迭代法：</p>
<div>$$
Ax = b \Rightarrow x = Gx + C
$$</div>

<p>不动点迭代的收敛核心在于G。</p>
<p>对于矩阵M，定义谱半径$\rho(M)$为M的特征值绝对值的最大值。</p>
<p>如果$\rho(G)&lt;  1$，则不动点迭代收敛。</p>
<p>分裂$A &#x3D; M - N$，则</p>
<div>$$
(M - N)x = b\Rightarrow\\
x = M^{-1}Nx + M^{-1}b
$$</div>

<p>当$\rho(M^{-1}N) &lt;  1$时，不动点迭代收敛。</p>
<p>Jacobi（雅克比）方法：$A &#x3D; D + L + U$, $M &#x3D; D$, $N &#x3D; - (L + U)$, $x^{k+1} &#x3D; D^{-1}[b - (L+U)x^k]$。</p>
<p>高斯-赛德方法：<br>$A &#x3D; D + L + U$, $M &#x3D; D + L$, $N &#x3D; -U$, $x^{k+1} &#x3D; (D+L)^{-1}(b - Ux^k)$。</p>
<p>这两种迭代都不一定收敛，但是实际中一般都可以。高斯赛德方法速度比雅克比快一倍。</p>
<h3 id="非线性方程求解"><a href="#非线性方程求解" class="headerlink" title="非线性方程求解"></a>非线性方程求解</h3><p>误差分析：</p>
<p>非线性方程$f(x) &#x3D; 0$，真解为$x^*$，近似解为$\hat x$。</p>
<p>残差：$||f(\hat x)||$</p>
<p>前向误差：$||\hat x - x^*||$，能更准确地描述解的精确程度。</p>
<p>绝对条件数：$1&#x2F;|f^\prime(x^*)|$</p>
<p>可见，如果f(x)在$x^*$处接近水平，则问题是病态的。</p>
<p>具有重根的问题也是病态的。</p>
<p>解法：</p>
<p>二分法：定义误差$e_k &#x3D; x_k - x^*$，定义迭代法的收敛速度定义：$\lim_{k\rightarrow \infty}\frac{||e_{k + 1}||}{||e_k||^r} &#x3D; C$，则收敛速度为$r$。r&#x3D;1称为线性的，r&gt;1称为超线性的，r&#x3D;2称为平方的。二分法的迭代次数与函数的具体形式无关。</p>
<p>不动点迭代法：</p>
<p>收敛性：</p>
<div>$$
\lim_{k\rightarrow \infty}\frac{||e_{k+1}||}{||e_k||} \\=\lim_{k\rightarrow \infty}\frac{g(x_k) - x^*}{x_k - x^*} \\
= \lim_{k\rightarrow \infty} g^\prime (\xi_k) = g^\prime(x^*) 
$$</div>

<p>绝对条件数为$g^\prime(x^*)$。如果$|g^\prime(x^*)|$非零，则收敛是线性的，如果为0，则是超线性的。</p>
<p>牛顿迭代法：</p>
<div>$$
x_{k + 1} = x_k - \frac{f(x_k)}{f^\prime(x_k)}
$$</div>

<p>由于$g^\prime(x^*)&#x3D;0$，收敛是超线性的。进一步分析得到$\lim_{k\rightarrow \infty}\frac{x_{k+1} - x^*}{(x_k - x^*)^2} &#x3D; \frac{f^{\prime\prime}(x^*)}{2f^\prime(x)}$，因此牛顿法是平方收敛的。</p>
<p>牛顿法的特点：</p>
<ul>
<li>初值的选取很重要</li>
<li>$f^\prime(x)\ne 0$</li>
<li>速度快，但是可能出现振荡的情况</li>
<li>对多重根的收敛速度退化为线性</li>
<li>涉及到求导，有时候比较困难</li>
</ul>
<p>准牛顿法：免去了求导</p>
<div>$$
x_{k + 1} = x_k - \frac{f(x_k)}{g_k}
$$</div>

<p>割线法：准牛顿法的一种</p>
<div>$$
g_k = \frac{f(x_k) - f(x_{k - 1})}{x_k - x_{k - 1}}
$$</div>

<p>反插：割线法是用两次的迭代值确定一条直线，取直线与x轴的交点。可以采用反二次插值：用前三次迭代值确定抛物线$x &#x3D; p(y)$，取它与x轴的交点。</p>
<p>二分法较安全，但速度慢；迭代法速度快，但不安全。可以在区间较大时采用二分法缩小区间，等区间较小时再采用迭代法。</p>
<h3 id="拟合与插值"><a href="#拟合与插值" class="headerlink" title="拟合与插值"></a>拟合与插值</h3><h4 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h4><p>如果方程的数目多于未知数的数目，则是超定方程。</p>
<p>如果方程的数目少于未知数的数目，则是欠定方程。</p>
<p>超定方程在线性最小二乘的意义下得到一个近似解。</p>
<p>转而求解$A^TAx &#x3D; A^Tb$。如果矩阵A是列满秩的，则解唯一。</p>
<p>若$A^TA$是正定的，则有$A &#x3D; LL^T$。</p>
<p>可以采用QR分解将长方阵A简化：</p>
<div>$$
A = Q\begin{bmatrix}
R\\
0
\end{bmatrix}
$$</div>

<p>进一步，如果$Q &#x3D; \begin{bmatrix}Q_1\\Q_2\end{bmatrix}$，则$Rx &#x3D; Q_1^Tb$。</p>
<p>利用household变换进行QR分解。</p>
<p>正规方程方法的复杂度：$mn^2&#x2F;2  + n^3&#x2F;6$</p>
<p>household变换的复杂度：$mn^2 - n^3 &#x2F; 3$</p>
<p>如果m和n相当，则两种变换的复杂度相当，而m远大于n时，QR分解的复杂度是正规方程方法的两倍。</p>
<p>QR分解的适用性更宽。</p>
<h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>插值使得函数精确地通过给定数据点。</p>
<p>单项式基底：$\phi_j(x) &#x3D; x^{j - 1}$。给定点数越多的插值问题，病态性越高，插值多项式的系数不稳定。</p>
<p>霍纳法则：$t_1 + x(t_2+x(t_3+(\dotsb)))$，减少乘法次数。</p>
<p>拉格朗日插值：</p>
<div>$$
l_j(x) = \frac{\prod_{k = 1, k \ne j}^{n}(x - x_k)}{\prod_{k = 1, k\ne j}^{n}(x_j - x_k)}
$$</div>

<ul>
<li>确定形式容易</li>
<li>计算值困难</li>
<li>微分，积分不方便</li>
</ul>
<p>牛顿插值：基底取$\prod_{k &#x3D; 1}^{j - 1}(t - t_k)$。</p>
<ul>
<li>容易确定，系数较容易求解</li>
<li>计算可以通过类似霍纳法则的方法求得，时间复杂度低</li>
<li>在确定和求值之间形成了较好的平衡。</li>
</ul>
<h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><p>分为连续优化问题和离散优化问题。</p>
<p>可行点，约束集合。</p>
<h4 id="连续优化问题"><a href="#连续优化问题" class="headerlink" title="连续优化问题"></a>连续优化问题</h4><p>有线性规划和非线性规划问题。</p>
<p>线性规划：不细讲。</p>
<p>非线性规划：</p>
<p>（严格&#x2F;非严格）全局最小值，局部最小值。全局最小值的求解，甚至验证都很困难。</p>
<p>闭集：闭集是补集为开集的集合。如果一个集合中所有的极限点都是这个集合中的点，则这个集合是闭集。</p>
<p>有界闭集上的连续函数有全局最小值。如果不是闭的或者无界，就可能没有最小值。</p>
<p>$\lim_{||x||\rightarrow \infty} f(x) &#x3D; \infty$，称$f(x)$在无界闭集$S\sube \mathbb{R^n}$上是强制的。</p>
<p>如果连续函数$f$在无界闭集$S\sube \mathbb{R^n}$上是强制的，则$f$在$S$上存在全局最小值。</p>
<p>集合是凸的：任意两点的连线属于这个集合。</p>
<p>函数是凸的：区间内函数值不超过端点连线上的函数值。</p>
<p>如果集合和函数都是凸的，称为凸优化问题。</p>
<p>我们有如下结论：</p>
<ul>
<li>如果$f$是凸集$S\sube \mathbb{R^n}$上的凸函数，则在 $S\sube \mathbb{R^n}$的任意内点上连续</li>
<li>凸函数$f$在凸集$S\sube \mathbb{R^n}$上的任意局部最小值，都是$f$在$S\sube \mathbb{R^n}$上的全局最小值</li>
<li>严格凸函数$f$在凸集 $S\sube \mathbb{R^n}$上的局部最小值，是$f$在$S\sube \mathbb{R^n}$上的唯一全局最小值</li>
<li>如果$f$在有界闭集$S\sube \mathbb{R^n}$上严格凸，则$f$在$S\sube \mathbb{R^n}$上存在唯一的全局最小值</li>
<li>如果$f$在无界闭集 $S\sube \mathbb{R^n}$上严格凸，则$f$在$S\sube \mathbb{R^n}$上存在唯一全局最小值的充要<br>条件是$f$在$S\sube \mathbb{R^n}$上是强制的</li>
</ul>
<p>下面考虑无约束优化：</p>
<p>梯度为0的点是临界点。</p>
<p>临界点可能是局部最大值&#x2F;最小值&#x2F;鞍点。</p>
<p>如果函数是凸的，临界点就是全局最小值点。</p>
<p>海森矩阵正定，则f是凸的。</p>
<p>如果$x^*$是函数$f$的最小值，<br>则$\nabla f(x^*) &#x3D; 0$，$\nabla^2f(x^*)$非负定。</p>
<p>如果$\nabla f(x^*) &#x3D; 0$且$\nabla^2f(x^*)$正定，则$x^*$是严格局部最小值。</p>
<p>如果是凸优化，则$\nabla f(x^*) &#x3D; 0\Leftrightarrow f(x^*)$为严格局部最小值</p>
<p>矩阵的正定性：</p>
<ul>
<li>特征值全正</li>
<li>Cholesky分解唯一</li>
<li>顺序主子式的行列式全正</li>
</ul>
<p>拉格朗日乘数法：</p>
<div>$$
\mathcal{L}(x, \lambda) = f(x) + \lambda^Tg(x)
$$</div>

<p>海森矩阵：</p>
<div>$$
H_{\mathcal{L}}(x, \lambda) = \begin{bmatrix}
    B(x, \lambda) && J_g^T(x)\\
    J_g(x) && 0
\end{bmatrix}\\
B(x,\lambda) = H_f(x) + \sum_{i = 1}^m\lambda_iH_{g_i}(x)
$$</div>

<p>只要$B(x^*, \lambda^*)$正定，则$x^*$是极小值点。</p>
<p>敏感性和病态性：依赖于海森矩阵</p>
<ul>
<li>海森矩阵奇异，则极值问题病态</li>
<li>海森矩阵接近奇异，则极值问题敏感</li>
</ul>
<p>下面考虑一维优化问题：</p>
<p>单峰函数:最小值左侧递减，最小值右侧递增。</p>
<p>类似于二分法，可以用黄金分割搜索求单峰函数的极小值。</p>
<p>好处：每次迭代只需要更新一个点；安全性好；收敛速度线性；</p>
<p>坏处：收敛速度还可以提高。</p>
<p>方法二：逐次抛物插值。用两个端点和一个近似极值点拟合一条抛物线，取抛物线的最小值点作为新的近似极值点，反复直到收敛。</p>
<p>当初始点接近极值点时能够收敛；收敛是超线性的。</p>
<p>牛顿迭代法：</p>
<div>$$
x_{k + 1} = x_k - \frac{f'(x_k)}{f''(x_k)}
$$</div>

<p>实际上采用黄金分割搜索和逐次抛物插值混合方案，避免求函数的导数。</p>
<p>多维优化问题：</p>
<p>最速下降法：</p>
<div>$$
x_{k + 1} = x_k - \alpha_k\nabla f(x_k)
$$</div>

<p>确定$\alpha_k$：$\min_{\alpha_k} f(x_k - \alpha_k \nabla f(x_k))$</p>
<p>非常可靠，只要梯度不为0；速度可能不快，呈之字形；收敛速度线性；初值的选择很重要。</p>
<p>牛顿法：</p>
<div>$$
x_{k + 1} = x_k - H_f^{-1}(x_k)\nabla f(x_k)
$$</div>

<p>平方收敛，速度快于梯度下降；需要距离最优解很近；不需要搜索参数；如果目标具有连续的二阶偏导数，则海森矩阵对称。</p>
<p>拟牛顿法</p>
<div>$$
x_{k + 1} = x_k - \alpha_kB_k^{-1}\nabla f(x_k)
$$</div>

<h2 id="算法设计思想"><a href="#算法设计思想" class="headerlink" title="算法设计思想"></a>算法设计思想</h2><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li>可行性</li>
<li>局部最优</li>
<li>不可取消</li>
</ul>
<p>不是所有优化问题都能通过贪心算法求解，即使可以使用贪心算法，也不一定能够得到最优解。</p>
<p>如果一个优化问题可以通过局部最优选择得到全局最优解，则说这个问题满足贪心选择性质，此时可以简单高效地求得问题的最优解。</p>
<p>贪心策略可以有很多种。不同的算法有不同的性能。不一定得到全局最优解。</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>多阶段动态过程的优化问题</p>
<p>阶段：把问题分成几个相互联系的有顺序的几个环节，这些环节被称<br>为阶段</p>
<p>状态：某一阶段的出发位置称为状态。通俗的说状态是对问题在某一<br>时刻的进展情况的数学描述</p>
<p>决策：从某阶段的一个状态演变到下一个阶段某状态的选择</p>
<p>条件：最优化原理；无后效性</p>
<p>动态规划用空间换时间，有大量重叠子问题时才能体现它的优势。</p>
<p>例：Floyd算法，Viterbi译码</p>
<h3 id="蛮力法"><a href="#蛮力法" class="headerlink" title="蛮力法"></a>蛮力法</h3><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>快速排序</p>
<p>分治法：分成若干个小的同类问题</p>
<p>减治法：变成一个更小的同类问题</p>
<p>变治法：变成若干个更简单的问题</p>
<h3 id="搜索算法"><a href="#搜索算法" class="headerlink" title="搜索算法"></a>搜索算法</h3><p>组合优化问题的解空间指的是搜索答案的过程中搜索过的可行解。</p>
<p>回溯法：没有希望的解就不去搜索。</p>
<p>分支界限法：一边搜索一边给出当前部分解的下界。对于下界比搜索到的可行解还大的分支，不去搜索。下界的估计方法很重要。</p>
<p>回溯法和分支界限法都不能保证求解的效率。</p>
<h3 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h3><p>Sherwood算法</p>
<p>快速排序在某些序列下会发生时间复杂度的退化。随机划分元素，可以使得达到最坏复杂度的概率降到很低。</p>
<p>一般地，若确定型算法在最坏情况下的时间复杂度和它在平均情况下的时间复杂度有较大的差异，通过随机性可以消除这种差别。并不是避免这种最坏的情况发生，而是切除这种最坏情况和特定实例之间的联系。</p>
<p>Las Vegas算法</p>
<ul>
<li>随机化决策</li>
<li>减少算法运行的时间</li>
<li>有概率会失败</li>
<li>多尝试几次以提高成功率</li>
</ul>
<p>Monte Carlo算法</p>
<ul>
<li>概率为基础的统计模拟方法</li>
<li>不保证得到正确的解</li>
<li>设计合理，大量重复可以大概率得到高精度的解</li>
</ul>
<p>随机投点求面积</p>
<p>一个蒙特卡洛方法得到正确判定的概率不小于p，则算法是p正确的。</p>
<p>如果同一实例不会给出不同的解，称算法是一致的。</p>
<p>对于判定问题，如果能够保证返回true时是正确的，称为偏真的；保证返回false时是正确的，则算法是偏假的。</p>
<p>Sherwood:一定得到正确解，一般不会遇到最坏情况</p>
<p>Las Vegas:不一定得到正确解，但如果得到了一定是正确的</p>
<p>Monte Carlo:不一定得到正确解，即使得到了也不一定是正确的</p>
<h3 id="算法优化技术"><a href="#算法优化技术" class="headerlink" title="算法优化技术"></a>算法优化技术</h3><p>输入增强技术</p>
<ul>
<li><p>字符串匹配算法</p>
</li>
<li><p>计数排序</p>
</li>
</ul>
<p>预构造技术</p>
<ul>
<li><p>并查集</p>
</li>
<li><p>二叉查找树</p>
</li>
<li><p>倒排索引</p>
</li>
<li><p>堆和堆排序</p>
</li>
</ul>
<p>时空平衡</p>
<ul>
<li>比特逆序</li>
<li>散列</li>
</ul>
</div></section><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>Blither Boom</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://blitherboom812.github.io/2022/09/13/DataAndAlgorithms/" title="笔记-数据与算法">https://blitherboom812.github.io/2022/09/13/DataAndAlgorithms/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><span class="icon iconify" data-icon="ri:creative-commons-line"></span><span class="icon iconify" data-icon="ri:creative-commons-by-line"></span><span class="icon iconify" data-icon="ri:creative-commons-nc-line"></span><span class="icon iconify" data-icon="ri:creative-commons-sa-line"></span></a> unless otherwise stated.</li></ul></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2022/09/14/Physics/" rel="prev" title="大雾笔记"><span class="icon iconify" data-icon="ri:arrow-left-s-line"></span><span class="post-nav-text">大雾笔记</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2022/09/02/cpp-multi-file/" rel="next" title="使用VSCode进行c++/c多文件开发"><span class="post-nav-text">使用VSCode进行c++/c多文件开发</span><span class="icon iconify" data-icon="ri:arrow-right-s-line"></span></a></div></div></div><div class="hty-card" id="comment"></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2025 </span><span class="with-love" id="animate"><span class="icon iconify" data-icon="ri:cloud-line"></span></span><span class="author"> Blither Boom</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v6.2.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.11</span></div></footer></div><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><span class="icon iconify" data-icon="ri:arrow-up-s-line"></span><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><script>function initMourn() {
  const date = new Date();
  const today = (date.getMonth() + 1) + "-" + date.getDate()
  const mourn_days = ["4-4","9-18","12-13"]
  if (mourn_days.includes(today)) {
    document.documentElement.style.filter = "grayscale(1)";
  }
}
initMourn();</script></body></html>
---
title: 笔记-数据结构与算法
date: 2022-09-13 10:01:08
tags: note
katex: true
---

# 相关资源

[Princeton _Algorithm 4th Edition_](https://algs4.cs.princeton.edu/home/)

# 课程说明

## 课程内容

数据处理，数学模型，算法分析

非数值问题：

数据结构：线性表，栈，队列，串，树，图

非数值算法：查找，排序

数值问题：

误差分析

线性方程组

非线性方程

拟合与插值

最优化初步

算法设计：蛮力，分治、减治、贪心、动态规划、搜索算法

# 绪论

## 数据与算法

## 数学模型

对于现实世界的某一特定对象，为特定目的而得到的一个抽象的简化的数学结构。

### 算法

算法是问题的程序化解决方案。

算法强调精确定义的求解过程，并不是问题的答案。

设计实现算法，并没有得到答案，但是给出了一般的解决方案。

一个算法能够解决很多看似好无关系的问题，只要这些问题可以抽象为某种相同的算法。

### 数据

数据是客观世界的描述。

数据是信息的载体，是算法处理的对象。

算法是处理数据的系统。

人的因素也被纳入了数学模型的和算法。

IBM Watson

## 算法分析和算法设计

### 算法及其特性

算法的五个重要特性：

有穷性：一个算法必须可以在有穷步之后结束，且每一步可以在有穷时间内完成

确定性：算法的描述无歧义，算法的执行结果是确定的且精确地符合要求或期望

可行性：算法中描述的操作都可以通过已经实现的基本操作运算的有限次执行来实现

输入：一个算法有零个或多个输入，这些输入取自某个特定的对象集

输出：一个算法有一个或多个输出，输出量是算法计算的结果

### 算法的评价

#### 正确性

不含语法错误

几组一般的输入数据

精心选择的、典型、苛刻且带有刁难性的输入数据（衡量标准）

一切合法的输入数据

#### 健壮性

输入的数据非法

#### 可读性

描述清楚，便于理解

#### 高效率

占用的空间和时间资源

### 算法效率的衡量方法

和算法执行时间相关的因素有很多。

一个特定算法运行工作量的大小，是问题规模的函数。

#### 渐进时间复杂度

算法的渐进时间复杂度(Time Complexity): $T(n) = O[f(n)]$

Big-O 记号的形式化定义

- 若 f(n)是正整数 n 的一个函数，则$x_n = O[f(n)]$表示存在正的常数$M$和$n_0$， 使得当$n > n_0$时，都满足$|x_n| \le M|f(n)|$
- 标记的是算法效率的上限

##### 算法效率估算方法

- 算法执行的时间 = Σ 操作的执行次数 × 操作的执行时间
- 算法操作包括**控制操作**和**原操作**<br>一般来说，相比于循环体，控制操作本身的复杂度可被忽略。而在原操作中，我们又可以寻找其中执行次数最多的一种或几种操作，这些操作被称为基本操作。
- 选取算法中的**基本操作**
- 算法的执行时间与**基本操作执行次数之和**成正比

##### 描述指标

- 最好情况(best-case)：对于任何一个输入的运行时间下限
- 最坏情况(worst-case)：对于任何一个输入的运行时间下限
- 平均(average-complexity): 根据各种操作出现概率的分布进行加权平均
- 分摊(amortized complexity): 连续实施足够多次操作，总成本摊至单次操作

最重要的是平均情况下的性能

##### 引入大 O 表示的渐进时间复杂度和空间复杂度实际上是建立了算法效率分析的数学模型

##### 迅速找到会被多次反复执行的基本操作

##### 感兴趣的复杂度形式非常有限

##### 按照对数坐标画图

#### 空间复杂度

##### 算法空间

- 指令空间(instruction space): 用来存储程序指令所需的空间
- 数据空间(data space): 存储运行过程中常量和变量所需的空间
- 环境空间: 系统为程序运行，特别是函数调用提供的空间

##### 算法的渐进空间复杂度: $S(n) = O[f(n)]$

##### 输入数据所占空间只取决于问题本身，和算法无关，则只需要分析输入和程序之外的额外空间

### 数据结构

#### 数据元素和数据项

数据元素(Data Element): 数据的最小单位

数据项：(Data Item): 数据结构中讨论的最小单位

#### 数据结构是带结构的数据元素的集合

逻辑结构：集合，线性结构，树结构，图结构

存储结构：顺序存储，链式存储

#### 二元关系

##### 定义

定义：设有几何$M, N$, 其笛卡尔积$M \times N$的任意一个子集$R \in M \times N$

二元关系表示了集合$M$和集合$N$中元素之间的某种相关性。

若$(a, b) \in R$, 则称$a$为$R$的前件，$b$称为$R$的后件。

若$M = N$, 则称$R \sub M \times M$为 M 上的二元关系。

##### 二元关系的性质

设$R$为集合$M$上的一个二元关系：

(1) 自反性：对于每个$a \in M$, 有 $(a, a) \in R$;

反自反性： 对于所有$a \in M$, 有$(a, a) \notin R$;

(2) 对称性：当$(a, b) \in R$时，则$a = b$;

反对称性：当$(a, b) \in R$且$(b, a) \in R$时，必有$a = b$;

(3) 传递性： 当$(a, b) \in R$且$(b, c) \in R$ 时， 必有$(a, c) \in R$。

##### 常见的二元关系

等价关系：满足自反性、对称性、传递性

偏序关系：满足自反性、反对称性、传递性

全序关系：若$M$中的任意两个元素$a$和$b$是可比的，也就是说或者有$aRb$成立，或者有$bRa$成立，则称$R$是集合$M$上的全序关系(Totala Order Relation)

#### 数据类型(Data Type)

##### C 语言中的类型定义

五种基本数据类型：字符型，整型，浮点型，双精度浮点型和无值类型

程序中任何变量，常量都必须先定义类型。

整数类型 int 及定义在其上的操作：+, -, \*, /, %, ++, --

双精度浮点型 double 及定义在其上的操作：+, -, \*, /, ++, --

###### 数据类型用来刻画(程序)操作对象的特性

数据类型是一个元素的集合和定义在此集合上的一组操作的总称。

数据类型实现了信息的隐藏，把一切用户无需了解的细节封装在类型中。

高级语言中的数据类型分为原子类型和结构类型。

#### 抽象数据类型(Abstract Data Type, ADT)

是指一个数学模型以及定义在此数学模型上的一组操作。

数据抽象：描述的是实体的本质特征、功能以及外部用户接口

数据封装：将实体的外部特性和内在实现细节发呢里，对外部用户隐藏内部实现细节，使得应用和实现分离

ADT 的优点：

- 程序结构清晰，易于扩展易于维护而不失其效率
- 提高程序的数据安全性
- 大大增加了软件的复用程度

#### 抽象数据类型的描述

```
ADT 抽象数据类型名{
    数据对象: <数据对象的定义>
    数据关系: <数据关系的定义>
    基本操作: <基本操作的定义>
    基本操作名(参数表)
        初始条件: <初始条件描述>
        操作结果: <操作结果描述>
}ADT 抽象数据类型名
```

基本操作参数:

- 赋值参数提供输入值
- 引用参数以&打头，用于返回操作结果

# 数据结构

## 线性表

线性表的元素可以是各种各样的，但是同一线性表的元素必然具有相同特性-同质

线性表中的相邻元素之间存在有序关系-位序

线性表是一种“有序结果”，即在数据元素的非空有限集合中

- 存在唯一的一个被称为“第一个”的数据元素，无前驱；
- 存在唯一的一个被称为的“最后一个”的数据元素，无后继；
- 除第一个之外，每一个数据元素均只有一个直接前驱；
- 除最后一个之外，每个数据元素均只有一个直接后继

线性表中元素个数定义为线性表的长度

$$(a_0, a_1, \dots, a_{i-1}, a_i, a_{i+1}, \dots, a_{n-1})$$

若线性表为空，则其长度为 0，称为空表

在非空表中，每个数据元素都有一个确定的位置

- $a_0$是第 0 个数据元素，$a_{n-1}$是第$n-1$个数据元素
- $a_i$是第 i 个数据元素
- 称 i 为数据元素$a_i$在线性表中的位序

## 线性表 ADT

```Java
ADT List{
    数据对象:
    数据关系:
    基本操作：
    InitList(&L);
        操作结果：构造一个空的线性表L。
    DestroyList(&L);
        初始条件：线性表已存在。
        操作结果：销毁线性表L。
    IsEmpty(L);
        初始条件：线性表已存在。
        操作结果：若L为空表，则返回TRUE，否则返回FALSE。
    ListLength(L);
        初始条件：线性表L已存在。
        操作结果：用e返回L中第i个数据元素的值
    GetElem(L, i, &e);
        初始条件：线性表L已存在。
        操作结果；用e返回L中第i个数据元素的值。
    LocateElem(L, e, compare());
        初始条件：线性表L已存在，compare()是数据元素判定函数。
        操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。若这样的元素不存在，则返回-1。
    PriorElem(L, cur_e, &pre_e);
        初始条件：线性表L已存在。
        操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。
    ClearList(&L);
        初始条件：线性表L已存在；
        操作结果：将L重置为空表。
    ListInsert(&L, i, e);
        初始条件：线性表L已存在, 0 <=i <= ListLength(L)。
        操作结果：在L中第i个位置插入新的数据元素e，L的长度加1。
    ListDelete(&L, i, &e)
        初始条件：线性表L已存在，0 <= i <= ListLength(L) - 1。
        操作结果：删除L的第i个数据元素，用e返回其值，L的长度减1。
    ListTraverse(L, visit());
        初始条件：线性表L已存在。
        操作结果：依次对L的每个数据元素调用函数 visit()。

```

线性表的合并：$O(m+n)$

线性表的保序归并：$O(m+n)$

线性表的顺序存储：顺序表

- 用一组地址连续的存储单元依次存储线性表的数据元素

顺序表的主要操作：

插入操作：在顺序表的第 i 个位置插入一个新元素，使顺序表的长度增加到$n+1$

复杂度分析：

- 在顺序表的第$i$个位置插入一个新元素，需要移动$n - i$个元素；
- 假设从顺序表的第$i$个位置插入元素的先验概率为$p_i$
- 插入操作移动元素次数的期望为$E_{insert} = \sum_{i = 0}^n(n - i) \times p_i$

删除操作：把顺序表的第$i$个位置的元素从表中删除，使长度为$n$的顺序表的长度变为$n - 1$

复杂度分析：

- 把顺序表的第$i$个位置上的元素删除，需要移动$n - i -1$个元素
- 假设从顺序表的第$i$个位置删除元素的先验概率为$q_i$
- 删除操作移动元素次数的期望为: $E_{delete} = \sum_{i = 0}^{n - 1}(n - i - 1) \times q_i$

不失一般性，我们假设插入或删除元素出现在任何位置的概率都是相等的，因此有$p_i = p = 1/(n+1), q_i = q = 1/n$。

推导得到：
$$E_{insert} = \frac1{n+1}\sum_{i = 0}^n(n-i) = \frac n2\newline E_{delete} = \frac1n\sum_{i = 0}^{n - 1}(n - i - 1) = \frac{n - 1}2$$

## 单向链表

最简单的链表结构：链表节点(node)由两个域组成。

数据域：存储数据元素，

指针域：指向直接后继节点

单向链表的 C++实现：

```C++
class LinkList {
private:
    NODE *head;
public:
    LinkList() {head = NULL;}
    ~LinkList();
    bool clearSqList();
    bool IsEmpty(){return head ==  NULL;}
    bool GetElem(int i, int *e);
    int LocateElem(int e);
    bool PriorElem(int cur_e, int *next_e);
    bool NextElem(int cur_e, int* pre_e);
    bool Insert(int i, int e);
    bool Delete(int i, int *e);
    bool Traverse(bool (*visit)(int e));//遍历所有节点
}

```

单向链表的不足：

* 单链表的表长是一个隐含的值，遍历链表才能得到
* 在单链表中插入或者删除元素时，需要在链表中依序寻找操作位置
* 在链表中，元素的“位序”概念淡化，结点的“位置”概念强化
* 如何得到某个元素的前驱？

改进链表的设置：

* 增加“表长”、“表尾指针”和“当前位置指针”三个数据域

* 将基本操作中的“位序i”改为“指针p”

## 双向链表

由数据，前驱和后继构成。

方便寻找前驱，但是增加了维护成本。

## 顺序表和链表的比较：

顺序表

用一组地址连续的存储单元依次存储线性表中的数据元素

优点：可以随机存取

缺点：插入，删除操作需要移动表中的数据元素，事先确定规模，空间效率不高。

链表：

用一组“任意”的存储单元（附加指针）存储表中的数据元素

优点：插入，删除操作无需移动表中的数据元素，空间利用率高

缺点：不能随机存取

## 栈

栈是LIFO(Last In First Out，先进后出)的线性表。

允许插入和删除的一段称为栈顶(top), 另一端称为栈底(bottom)

### 栈的ADT

~~~C++
{
    Push(&s, e);
    Pop(&s, &e);
    ClearStack(&s);
} ADT Stack;
~~~

### 栈的表示和实现

栈的顺序表示

top指向最后一个元素可以，指向空也可以，但是实现时要自洽。

栈的链式表示

有头插入和尾插入两个方式

总体来看，头插入比尾插入的优势要更大。首先，插入时虽然头插入要修改的指针更多，但是时间复杂度小，头插入$O(1)$，尾插入$O(n)$。其次，如果以尾部为栈顶，删除时会很麻烦。

**静态分配**

```C++
#define STACK_MAX_SIZE 100
```
**动态分配**

程序隐含设定

```C++
#define STACK_INT_SIZE 100
#define STACKINCREMENT 10
```

用户给定

### 复杂度分析

顺序栈的效率分析

时间复杂度

* 进栈、出栈:$O(1)$
* 栈的溢出处理
* 如果栈元素时简单数据类型，则构造和销毁函数也是$O(1)$的

空间复杂度

* 顺序栈的长度构造时确定
* 空间利用效率低

链式栈的效率分析

时间复杂度

* 链式栈的入栈出栈是$O(1)$时间的
* 建立和销毁是$O(n)$时间的

空间复杂度

* 一般不会产生溢出
* 空间利用率高

### 栈的一些应用

显式应用：括号匹配，表达式求值，迷宫求解

隐式应用：函数调用，递归

系统栈

## 递归

栈与递归具有相似性。

Fibonacci的递归次数：$C(n) = O(t^n)$

(证明思路：归纳法证明$C(n) = 2F(n) - 1$, 根据F(n)通项可以判断。)

使用递推法的时间复杂度：$O(n)$.

经常需要进行递归的消除。消除方法：递推，循环等，没有统一的解决方案。可以借用显式栈实现非递归过程。

递归的评价：

* 简洁，便于理解，便于叙述和设计
* 运行效率低，无法控制递归堆栈的规模

## 队列

队列是FIFO(First In First Out, 先进先出)的线性表。

### 队列的表示和实现

队列的顺序表示法

入队: rear = rear + 1

出队: front = front + 1

需要判定队满和队空。

顺序队列的问题：被出队的空间不会再次被使用了。

循环队列：

队尾指针指向maxSize - 1时， 入列则指向0；

队头指针指向maxSize - 1，出列也指向0。

可以使用模运算实现。

缺点：无法区分队空和队满的状态。

区分方法：

设置一个空位；设置标志；设置队列长度变量

队列的链式表示法

入队不会出现队满的问题，出队可能回有队空的问题，队空的条件为front = NULL.

## 串

串是有线长度的字符序列。

串的长度是字符个数。

字符在串中的位置。

两个串相等的条件。

子串和主串，子串在主串中的位置。

### 匹配算法

Brute-Force算法：一个一个比。复杂度最高O(m * n)。

KMP算法：尽可能跳过更多不必要的匹配。复杂度最多O(m + n)。

Horspool算法：启发式算法。复杂度低则O(m/n)，高则O(m * n + s)，s为字符表规模

Boyer-Moore算法：最坏O(n)。KMP和Horspool的综合（或者说Horspool是BM算法的简化版本。）

## 树与二叉树

空树，子树。

结点（node）是树的基本单位。

结点的度(degree)：结点的子树个数。

树的度：结点度的最大值。

k叉树：树的度为k

child, parent, cousin, ancestor, descendant

depth/height